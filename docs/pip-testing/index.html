<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>

    <!--
        TODO: UI. Have a pip color chooser that lets you choose from the 5 colors. Have a data field for the number 
                  with an up/down. Allow you to add new rows for new pips, and there are three columns. 
                  Pip color chooser also needs a 'no pip' option.
        TODO: UI. Be able to save a result so you can compare later. 
        TODO: UI. Want to do charting. This coulde include showing the charting of all values calculated, with the 
                  ones where the operator was true in a different colour. Also could be a chart for the saved tests.
                  This will involve various rejigging in the engine of the code.
        TODO: Some kind of best fit notion. Have it run over the flips looking for the best return value.
              This involves indicating something is variable. 
              One approach is to indicate the deck as WG*BK*, and it will adjust those numbers, keeping a max of 40.
              It could know the counts for how many of each pip type there are. Or maybe just the ones that have less 
              than 14 cards. 
    -->


    <script>

        // Knuth Fisher-Yates algorithm
        function deck_shuffle(arr) {
            for(let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * i);
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function pattern_to_pip_set(pip_pattern) {
            // convert [0-9]*[A-Z]* to array of [A-Z]* : [0-9]*
            results = pip_pattern.split(/(\d+)/);
            let pip_set = {};
            for (let i = 0; i < results.length - 1; i += 2) {
              pip_set[results[i]] = results[i+1];
            }
            return pip_set;
        }

        function pip_set_to_pattern(pip_set) {
            text = "";
            for (let key in pip_set) {
                // check if the property/key is defined in the object itself, not in parent
                if (pip_set.hasOwnProperty(key)) {           
                    count = pip_set[key];
                    text = text + key + count;
                }
            }
            return text;
        }

        // Count how many colours show
        function count_colours(flip_result, pip_match) {
//                console.log("Result: " + flip_result);
            colour_count = 0;
            if(flip_result.length > 1) {
                if(pip_match == '*' || pip_match.includes(flip_result.charAt(0))) {
                    colour_count++;
                }
                last_char = flip_result.charAt(0);
                for (let i = 1; i < flip_result.length; i++) {
                    if(flip_result.charAt(i) != last_char) {
                        if(pip_match == '*' || pip_match.includes(flip_result.charAt(i))) {
                            colour_count++;
                        }
                        last_char = flip_result.charAt(i);
                    }
                }
            }
            return colour_count;
        }

        // Count how many times a colour shows
        function count_pips(flip_result, pip_match) {
//                console.log("Result: " + flip_result);
            colour_count = 0;
            if(flip_result.length > 1) {
                last_char = flip_result.charAt(0);
                for (let i = 0; i < flip_result.length; i++) {
                    if(pip_match == '*' || pip_match.includes(flip_result.charAt(i))) {
                        colour_count++;
                    }
                }
            }
            return colour_count;
        }

        // TODO: Need to implement OR and presumably NOT.
        //       Note that the AND implementation here is quite hacky.
        /*
         * Build a function that represents the entered query. Note that this function handles 
         * splitting a query down into a group of statements and then uses precompile_statement
         */
        function precompile_condition(condition, flip_result) {
            results = condition.split(/( AND )/);
            if(results.length > 1) {
                statements = [];
                for (let result of results) {
                    if(result != " AND ") {
                        statements.push(precompile_statement(result, flip_result));
                    }
                }
                compound_func_ptr = function(fr) {
                    for (let statement of statements) {
                        if(!statement(fr))  {
                            return false;
                        }
                    }
                    return true;
                }
                return compound_func_ptr;
            } else {
                return precompile_statement(condition, flip_result);
            }
        }
        /*
    * count(X) OP Y; where Y is an Integer; OP is < = > >= <=; and X is either * or a pip combination
         * colours(X) OP Y; where letters are the same as above.
         */
        function precompile_statement(condition, flip_result) {
            // Parse the condition
            let found = condition.match(/([a-z_]+)\(([*OBKGW]+)\)([=<>]+)(.*)/);
            if(found) {
                let term = found[1]
                let pip_combination = found[2]
                let operator = found[3]
                let amount = parseInt(found[4])
                //console.log("Parsed to term: "+term+", pc:"+pip_combination+", op:"+operator+", am:"+amount);

                let func_ptr = null;
                if(term.match(/colou?rs/)) {
                    func_ptr = function(fr) {
                        return count_colours(fr, pip_combination);
                    }
                } else if(term.match(/count/)) {
                    func_ptr = function(fr) {
                        return count_pips(fr, pip_combination);
                    }
                } else {
                    console.log("Need to code more combination handling code");
                }

                if(operator == '=') {
                    return function(fr) {
                        return func_ptr(fr) == amount;
                    }
                } else if(operator == '<') {
                    return function(fr) {
                        return func_ptr(fr) < amount;
                    }
                } else if(operator == '>') {
                    return function(fr) {
                        return func_ptr(fr) > amount;
                    }
                } else if(operator == '<=') {
                    return function(fr) {
                        return func_ptr(fr) <= amount;
                    }
                } else if(operator == '>=') {
                    return function(fr) {
                        return func_ptr(fr) >= amount;
                    }
                } else {
                    console.log("Need to code more conditions...");
                }
            } else {
                console.log("Condition '" + condition + "' is not supported. ");
            }
        }

        /*
         * Returns an array of percentages that match the array of conditions
         */
        function run_test(pip_set, conditions, iteration_count, flip_count) {

            test_conditions = [];
            result_list = [];
            for (let condition of conditions) {
                test_conditions.push(precompile_condition(condition));
                result_list.push(0);
            }
    
            // Build Deck
            deck = [];
            for (let key in pip_set) {
                // check if the property/key is defined in the object itself, not in parent
                if (pip_set.hasOwnProperty(key)) {           
                    count = pip_set[key];
                    for (let i = 0; i < count; i++) {
                        deck.push(key);
                    }
                }
            }
    
            // Need to then iterate the draws over the deck. For each draw we need to collate statistics.
            for (let iteration = 0; iteration < iteration_count; iteration++) {
                deck_shuffle(deck);
                result = "";
                white_pipped = false;
                flip_count_tmp = flip_count;
                for (let flip_index = 0; flip_index < flip_count_tmp; flip_index++) {
                    result += deck[flip_index];
                    if(!white_pipped) {
                        if(deck[flip_index].includes("W")) {
                            flip_count_tmp += 2;
                            white_pipped = true;
                        }
                    }
                }
                result = result.split('').sort().join('');
                for (let i = 0; i < test_conditions.length; i++) {
                    if(test_conditions[i](result)) {
                        result_list[i] = result_list[i] + 1;
                    }
                }
            }

            for (let i = 0; i < test_conditions.length; i++) {
                result_list[i] = (result_list[i] * 100) / iteration_count;
            }
//            console.log("Results: " + result_list);
            return result_list;
        }

        function test_from_form() {
            flip_count=parseInt($("#flip_count").val() );
            iteration_count=parseInt( $("#iteration_count").val() );
            query=$("#query").val();
            pip_pattern=$("#pip_pattern").val();
            // colours(*)=4
            pip_set = pattern_to_pip_set(pip_pattern);
            //console.log("Running: run_test(" + pip_set_to_pattern(pip_set) + ", " + query + ", " + iteration_count + ", " + flip_count + ")");
            result = run_test( pip_set, [ query ], iteration_count, flip_count )[0];

            $("#percentage_result").html(Math.round(result) + "%");
            return false;
        }
    </script>
    </head>
    <body>
<h2>Pip Tester</h2>

    <form>
        <label>Deck Pips (eg: WG12OK28)</label><input id="pip_pattern"/><br/>
        <label>Flips (eg: flip X cards)</label><input id="flip_count"/><br/>
        <label>Iterations (how many times to test)</label><input id="iteration_count"/><br/>
        <label>PIPQL Query (eg: colours(*)=4)</label><input id="query"/><br/>
        <button type="button" onClick="test_from_form()">Calculate %age</button>
    </form>
    <br/><br/>
    <span id="percentage_result"></span>

    <h3>PIPQL Help</h3>
    <p>There are currently two functions available in PIPQL: </p>
    <ol>
        <li>count. This counts the number of times a pip shows. Its parameter is unique, so count(O) is the same as count(OO); that is the second O is meaningless. Using count(*) is a shorthand to count all pips that show.  </li>
        <li>colours/colors. This counts the number of times a colour shows. Again the parameter is unique, so colours(OO) matches colours(O). colours(*) counts all the colours, colours(OB) would count how often an O or B shows. colours(OB) will never be greater than 2; as an example. </li>
    </ol>

    <h3>Deck Format</h3>
    <p>Decks are described (until a nicer UI is made) as pieces of text consisting of the pips on a card type, followed by the number of those cards. O=Orange, B=Blue, K=Black, W=White, G=Green. </p>

    <h3>Examples</h3>
    <ul>
        <li>Grapple flipping two pips:  colours(*)=4</li>
        <li>Chromia flipping at least WW: count(W)&gt;1</li>
        <li>Ultra Magnus flipping OOBB: count(O)&gt;=2 AND count(B)&gt;=2</li>
        <li>Fortress Maximus flipping OK: colours(OK)=2</li>
        <li>Private Red Alert flipping WOB: colours(WOB)=3</li>
        <li>Slipstream flipping &gt;2 colours: colours(*)&gt;2</li>
    </ul>

    <h3>Provisos</h3>
    <p>Enter weird input, you'll get weird behaviour. Enter a huge number of iterations, your browser will lock up. 100000 is probably as high as you want/need to go. </p>

    </body>
    </html>
