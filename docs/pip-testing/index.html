<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>

    <script>

        // Knuth Fisher-Yates algorithm
        function deck_shuffle(arr) {
            for(let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * i);
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function pattern_to_pip_set(pip_pattern) {
            // convert [0-9]*[A-Z]* to array of [A-Z]* : [0-9]*
            results = pip_pattern.split(/(\d+)/);
            let pip_set = {};
            for (let i = 0; i < results.length - 1; i += 2) {
              pip_set[results[i]] = results[i+1];
            }
            return pip_set;
        }

        function pip_set_to_pattern(pip_set) {
            text = "";
            for (let key in pip_set) {
                // check if the property/key is defined in the object itself, not in parent
                if (pip_set.hasOwnProperty(key)) {           
                    count = pip_set[key];
                    text = text + key + count;
                }
            }
            return text;
        }

        // Count how many colours show
        function count_colours(flip_result, pip_match) {
//                console.log("Result: " + flip_result);
            colour_count = 0;
            if(flip_result.length > 1) {
                if(pip_match == '*' || pip_match.includes(flip_result.charAt(0))) {
                    colour_count++;
                }
                last_char = flip_result.charAt(0);
                for (let i = 1; i < flip_result.length; i++) {
                    if(flip_result.charAt(i) != last_char) {
                        if(pip_match == '*' || pip_match.includes(flip_result.charAt(i))) {
                            colour_count++;
                        }
                        last_char = flip_result.charAt(i);
                    }
                }
            }
            return colour_count;
        }

        // Count how many times a colour shows
        function count_pips(flip_result, pip_match) {
//                console.log("Result: " + flip_result);
            colour_count = 0;
            if(flip_result.length > 1) {
                last_char = flip_result.charAt(0);
                for (let i = 0; i < flip_result.length; i++) {
                    if(pip_match == '*' || pip_match.includes(flip_result.charAt(i))) {
                        colour_count++;
                    }
                }
            }
            return colour_count;
        }

/*

count(OB)  :   Do I want to know the number of O and B? i.e.: 3 O and 2 B cards would lead to a '2'
               Or do I want to know the number of OB cards; i.e. 3 O and 2 B would be '0'

               Maybe the former is has(OB). Or is it that it needs to be OB vs O+B. 
               What is 'count all the pips hit'?
               count(distinct(*)) would be the SQL. Painful here, so let's simplify to count_distinct(*).

               So we have count(.) and count_distinct(.). 
               Then we need to identify pip values.
               count_distinct(OB) would mean the number of cards with an orange and a blue. 
               Would a white/orange/blue be true?

               Perhaps:

               count_have(OB) would mean count the number of cards that have an O and a B on them
               count_is(OB) would mean count the number of OB cards
               count_unique_colours(*) would mean count the different pip colours


               sum(O) would add up the number of O pips
               sum(OB) would add up the number of ... wtf would it mean?

               Support boolean logic?

               count_have(O|B|K)
               count_is(OB|OK|OO|O) ?

               I AM CODING A DATABASE QUERY ENGINE AND QUERY OPTIMIZER. AARGGH.



               .... reset.

               colours(*) tells you how many pip colours showed.
               count_cards_with(WOB) counts how many WOB cards there are
               count(WOB) counts how many WOB pips show. ie: WOOBB would be 1.
               count(W|O|B) counts how many W,O,B pips shows. ie: WOOBB would be 5.
*/
               


// TODO: Need to implement AND and OR. And probably NOT. First just AND.
//       This means having a layer on top of the current code. 
//    Example:   f(x)=p AND g(y)=q.  So we have a 'joiner', which can be AND or OR.
        function precompile_condition(condition, flip_result) {
            results = condition.split(/( AND )/);
            if(results.length > 1) {
                statements = [];
                for (let result of results) {
                    if(result != " AND ") {
                        console.log("Precompiling: " + result);
                        statements.push(precompile_statement(result, flip_result));
                    }
                }
                compound_func_ptr = function(fr) {
                    for (let statement of statements) {
                        if(!statement(fr))  {
                            return false;
                        }
                    }
                    return true;
                }
                return compound_func_ptr;
            } else {
                return precompile_statement(condition, flip_result);
            }
        }
        /*
         * count(X) OP Y; where Y is an Integer; OP is < = >; and X is either * or a pip combination
         */
        function precompile_statement(condition, flip_result) {
            // Parse the condition
            let found = condition.match(/([a-z_]+)\(([*OBKGW]+)\)([=<>]+)(.*)/);
            if(found) {
                let term = found[1]
                let pip_combination = found[2]
                let operator = found[3]
                let amount = parseInt(found[4])
                //console.log("Parsed to term: "+term+", pc:"+pip_combination+", op:"+operator+", am:"+amount);

                let func_ptr = null;
                if(term.match(/colou?rs/)) {
                    func_ptr = function(fr) {
                        return count_colours(fr, pip_combination);
                    }
                } else if(term.match(/count/)) {
                    func_ptr = function(fr) {
                        return count_pips(fr, pip_combination);
                    }
                } else {
                    console.log("Need to code more combination handling code");
                }

                if(operator == '=') {
                    return function(fr) {
                        return func_ptr(fr) == amount;
                    }
                } else if(operator == '<') {
                    return function(fr) {
                        return func_ptr(fr) < amount;
                    }
                } else if(operator == '>') {
                    return function(fr) {
                        return func_ptr(fr) > amount;
                    }
                } else if(operator == '<=') {
                    return function(fr) {
                        return func_ptr(fr) <= amount;
                    }
                } else if(operator == '>=') {
                    return function(fr) {
                        return func_ptr(fr) >= amount;
                    }
                } else {
                    console.log("Need to code more conditions...");
                }
            } else {
                console.log("Condition '" + condition + "' is not supported. ");
            }
        }

        // Need to represent the input of the cards.
        // O, B, OB, etc.
        // Returns an array of percengages that match the array of conditions
        function run_test(pip_set, conditions, iteration_count, flip_count) {

            test_conditions = [];
            result_list = [];
            for (let condition of conditions) {
                test_conditions.push(precompile_condition(condition));
                result_list.push(0);
            }
    
            // Build Deck
            deck = [];
            for (let key in pip_set) {
                // check if the property/key is defined in the object itself, not in parent
                if (pip_set.hasOwnProperty(key)) {           
                    count = pip_set[key];
                    for (let i = 0; i < count; i++) {
                        deck.push(key);
                    }
                }
            }
    
            // Need to then iterate the draws over the deck. For each draw we need to collate statistics.
            for (let iteration = 0; iteration < iteration_count; iteration++) {
                deck_shuffle(deck);
                result = "";
                white_pipped = false;
                flip_count_tmp = flip_count;
                for (let flip_index = 0; flip_index < flip_count_tmp; flip_index++) {
                    result += deck[flip_index];
                    if(!white_pipped) {
                        if(deck[flip_index].includes("W")) {
                            flip_count_tmp += 2;
                            white_pipped = true;
                        }
                    }
                }
                result = result.split('').sort().join('');
                for (let i = 0; i < test_conditions.length; i++) {
                    if(test_conditions[i](result)) {
                        result_list[i] = result_list[i] + 1;
                    }
                }
            }

            for (let i = 0; i < test_conditions.length; i++) {
                result_list[i] = (result_list[i] * 100) / iteration_count;
            }
            console.log("Results: " + result_list);
            return result_list;
        }

        function test_from_form() {
            console.log("Testing");
            flip_count=parseInt($("#flip_count").val() );
            iteration_count=parseInt( $("#iteration_count").val() );
            query=$("#query").val();
            pip_pattern=$("#pip_pattern").val();
            // colours(*)=4
            pip_set = pattern_to_pip_set(pip_pattern);
            //console.log("Running: run_test(" + pip_set_to_pattern(pip_set) + ", " + query + ", " + iteration_count + ", " + flip_count + ")");
            result = run_test( pip_set, [ query ], iteration_count, flip_count )[0];

            $("#percentage_result").html(Math.round(result) + "%");
            return false;
        }
    </script>
    </head>
    <body>
<h2>Pip Tester</h2>
    <script>
/*
        run_test( { "WG" : 12, "OK" : 14, "BK" : 14 }, [ "colours(*)=4" ], 100000, 3 );   // 22.2% = 4
        run_test( { "WG" : 12, "OK" : 28 }, [ "colors(*)=4" ], 100000, 3 );   // 50.5% = 4
        run_test( { "W" : 12, "OK" : 14, "BK" : 14 }, [ "count(*)=4" ], 100000, 2 );
        run_test( { "W" : 20, "OK" : 10, "BK" : 10 }, [ "count(*)=4" ], 100000, 2 );
        run_test( { "Wg" : 20, "OK" : 14, "BK" : 6 }, [ "count(*)=4" ], 100000, 2 );
        run_test( { "WG" : 12, "OK" : 28 }, [ "count(*)=4" ], 100000, 2 );   // 50.5% = 4
        run_test( { "WG" : 12, "W" : 3, "OK" : 25 }, [ "count(*)=4" ], 100000, 2 );
        run_test( { "WG" : 12, "W" : 6, "OK" : 22 }, [ "count(*)=4" ], 100000, 2 );
        run_test( { "WG" : 12, "W" : 9, "OK" : 19 }, [ "count(*)=4" ], 100000, 2 );
        run_test( { "WG" : 21, "OK" : 19 }, [ "count(*)=4" ], 100000, 2 );
        run_test( { "WG" : 24, "OK" : 16 }, [ "count(*)=4" ], 100000, 2 );
        run_test( { "WG" : 25, "OK" : 15 }, [ "count(*)=4" ], 100000, 2 );
        run_test( { "WG" : 26, "OK" : 14 }, [ "count(*)=4" ], 100000, 2 );
        */

    </script>

    <form>
        <label>Deck Pips (eg: WG12OK28)</label><input id="pip_pattern"/><br/>
        <label>Flips (eg: flip X cards)</label><input id="flip_count"/><br/>
        <label>Iterations (how many times to test)</label><input id="iteration_count"/><br/>
        <label>PIPQL Query (eg: colours(*)=4)</label><input id="query"/><br/>
        <button type="button" onClick="test_from_form()">Calculate %age</button>
    </form>
    <br/><br/>
    <span id="percentage_result"></span>

    <!--

        TODO: UI. Have a pip color chooser that lets you choose from the 5 colors. Have a data field for the number 
                  with an up/down. Allow you to add new rows for new pips, and there are three columns. 
                  Pip color chooser also needs a 'no pip' option.
        TODO: UI. Be able to save a result so you can compare later. 
    -->

    <h3>PIPQL Help</h3>
    <p>There are currently two functions available in PIPQL: </p>
    <ol>
        <li>count. This counts the number of times a pip shows. Its parameter is unique, so count(O) is the same as count(OO); that is the second O is meaningless. Using count(*) is a shorthand to count all pips that show.  </li>
        <li>colours/colors. This counts the number of times a colour shows. Again the parameter is unique, so colours(OO) matches colours(O). colours(*) counts all the colours, colours(OB) would count how often an O or B shows. colours(OB) will never be greater than 2; as an example. </li>
    </ol>

    <h3>Deck Format</h3>
    <p>Decks are described (until a nicer UI is made) as pieces of text consisting of the pips on a card type, followed by the number of those cards. O=Orange, B=Blue, K=Black, W=White, G=Green. </p>

    <h3>Examples</h3>
    <ul>
        <li>Grapple flipping two pips:  colours(*)=4</li>
        <li>Chromia flipping at least WW: count(W)&gt;1</li>
        <li>Ultra Magnus flipping OOBB: count(O)&gt;=2 AND count(B)&gt;=2</li>
        <li>Fortress Maximus flipping OK: colours(OK)=2</li>
        <li>Private Red Alert flipping WOB: colours(WOB)=3</li>
        <li>Slipstream flipping &gt;2 colours: colours(*)&gt;2</li>
    </ul>

    <h3>Provisos</h3>
    <p>Enter weird input, you'll get weird behaviour. Enter a huge number of iterations, your browser will lock up. 100000 is probably as high as you want/need to go. </p>

    </body>
    </html>
